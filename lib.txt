Directory Structure:
├── src/
  └── constants.ts
  └── index.ts
  └── schema.ts
  └── types.ts
├── tests/
  └── replication.test.ts
  └── site.test.ts
└── tsconfig.json
└── vite.config.js

File Contents:

File: src/index.ts
================================================
export * from './constants';
export * from './schema';
export * from './types';


File: tests/replication.test.ts
================================================
import {
  describe,
  test,
  expect,
  beforeAll,
  afterAll,
  afterEach, // Added afterEach for cleanup
  vi,
} from 'vitest';
import type { ProgramClient } from '@peerbit/program';
import { TestSession } from '@peerbit/test-utils';
import { delay } from '@peerbit/time';

import { Site, Release } from '../src/schema';
import { DEFAULT_SITE_ID } from '../src/constants';
import {
  RELEASE_CATEGORY_ID_PROPERTY,
  RELEASE_CONTENT_CID_PROPERTY,
  RELEASE_NAME_PROPERTY,
  RELEASE_THUMBNAIL_CID_PROPERTY,
} from '../src/constants';
import type { ReleaseData } from '../src/types';

describe('Site Replication', () => {
  let session: TestSession;
  let peer1: ProgramClient, peer2: ProgramClient;
  let site1: Site | undefined, site2: Site | undefined; // Initialize as undefined

  beforeAll(async () => {
    session = await TestSession.connected(2);
    peer1 = session.peers[0];
    peer2 = session.peers[1];
  }, 20000);

  afterEach(async () => { // Clean up sites after each test
    if (site2 && !site2.closed) {
      await site2.close();
    }
    site2 = undefined; // Reset for the next test

    if (site1 && !site1.closed) {
      await site1.close();
    }
    site1 = undefined; // Reset for the next test
  });

  afterAll(async () => {
    // afterEach handles individual site cleanup.
    // This afterAll is primarily for stopping the session.
    if (session) {
      await session.stop();
    }
  });

  test('opens the same Site program on two peers and replicates a release', async () => {
    const siteCreator = new Site(DEFAULT_SITE_ID);
    const releaseData: ReleaseData = {
      [RELEASE_NAME_PROPERTY]: 'TPB AFK: The Pirate Bay Away from Keyboard',
      [RELEASE_CATEGORY_ID_PROPERTY]: 'movie',
      [RELEASE_CONTENT_CID_PROPERTY]: 'QmPSGARS6emPSEf8umwmjdG8AS7z7o8Nd36258B3BMi291',
      [RELEASE_THUMBNAIL_CID_PROPERTY]: 'bafkreiemqveqhpksefhup46d77iybtatf2vb2bgyak4hfydxaz5hxser34',
    };
    site1 = await peer1.open(siteCreator);
    const site1Address = site1.address;
    expect(site1Address).toBeDefined();

    site2 = await peer2.open<Site>(site1Address, {
      args: { replicate: true },
    });

    expect(site2).toBeInstanceOf(Site);
    expect(site2.address).toEqual(site1.address);

    await site1.waitFor(peer2.identity.publicKey);
    await site2.waitFor(peer1.identity.publicKey);

    const newRelease = new Release(releaseData);
    const originalReleaseId = newRelease.id;

    await site1.addRelease(newRelease);

    let replicatedRelease: Release | undefined;
    await vi.waitUntil(
      async () => {
        // Ensure site2 is defined before calling getRelease
        replicatedRelease = site2 ? await site2.getRelease(originalReleaseId) : undefined;
        return !!replicatedRelease;
      },
      { timeout: 20000, interval: 1000 },
    );

    expect(replicatedRelease, `Release ${originalReleaseId} did not replicate to Peer 2`).toBeDefined();
    if (replicatedRelease) {
      expect(replicatedRelease.id).toEqual(originalReleaseId);
      expect(replicatedRelease.name).toEqual(releaseData[RELEASE_NAME_PROPERTY]);
      expect(replicatedRelease.contentCID).toEqual(releaseData[RELEASE_CONTENT_CID_PROPERTY]);
      expect(replicatedRelease.categoryId).toEqual(releaseData[RELEASE_CATEGORY_ID_PROPERTY]);
      expect(replicatedRelease.thumbnailCID).toEqual(releaseData[RELEASE_THUMBNAIL_CID_PROPERTY]);
    }
  }, 45000);

  test('replicates a release added before the second peer opens the site', async () => {
    const siteCreator = new Site(DEFAULT_SITE_ID);

    const releaseData: ReleaseData = {
      [RELEASE_NAME_PROPERTY]: 'RiP!: A Remix Manifesto',
      [RELEASE_CATEGORY_ID_PROPERTY]: 'movie',
      [RELEASE_CONTENT_CID_PROPERTY]: 'QmTWWUmvC9txvE7aHs9xHd541qLx3ax58urvx3Kb3SFK2Q',
      [RELEASE_THUMBNAIL_CID_PROPERTY]: 'Qmb3eeESRoX5L6NhTYLEtFFUS1FZgqe1e7hdBk2f57DUGh',
    };

    site1 = await peer1.open(siteCreator);
    const site1Address = site1.address;
    expect(site1Address).toBeDefined();

    const newRelease = new Release(releaseData);
    const originalReleaseId = newRelease.id;

    await site1.addRelease(newRelease);
    await delay(200); // Allow add operation to settle

    site2 = await peer2.open<Site>(site1Address, {
      args: { replicate: true },
    });

    expect(site2).toBeInstanceOf(Site);
    expect(site2.address).toEqual(site1.address);

    await site1.waitFor(peer2.identity.publicKey);
    await site2.waitFor(peer1.identity.publicKey);

    let replicatedRelease: Release | undefined;
    await vi.waitUntil(
      async () => {
        replicatedRelease = site2 ? await site2.getRelease(originalReleaseId) : undefined;
        return !!replicatedRelease;
      },
      { timeout: 25000, interval: 1000 },
    );

    expect(replicatedRelease, `Pre-existing release ${originalReleaseId} did not replicate to Peer 2`).toBeDefined();
    if (replicatedRelease) {
      expect(replicatedRelease.id).toEqual(originalReleaseId);
      expect(replicatedRelease.name).toEqual(releaseData[RELEASE_NAME_PROPERTY]);
      expect(replicatedRelease.contentCID).toEqual(releaseData[RELEASE_CONTENT_CID_PROPERTY]);
      expect(replicatedRelease.categoryId).toEqual(releaseData[RELEASE_CATEGORY_ID_PROPERTY]);
      expect(replicatedRelease.thumbnailCID).toEqual(releaseData[RELEASE_THUMBNAIL_CID_PROPERTY]);
    }
  }, 50000);
});


File: tsconfig.json
================================================
{
  "compilerOptions": {
    "allowSyntheticDefaultImports": true,
    "module": "esnext",
    "target": "esnext",
    "sourceMap": true,
    "moduleResolution": "node",
    "skipLibCheck": true,
    "strict": true,
    "isolatedModules": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "types": ["node"],
    "baseUrl": ".",
    "paths": {
      "/@/*": ["./src/*"]
    }
  },
  "include": [
    "src/**/*.ts",
    "../../types/**/*.d.ts",
  ],
  "exclude": [
    "node_modules",
    "dist"
  ]
}


File: vite.config.js
================================================
import {join} from 'node:path';
import {chrome} from '../../.electron-vendors.cache.json';
import {injectAppVersion} from '../../version/inject-app-version-plugin.mjs';

const PACKAGE_ROOT = __dirname;
const PROJECT_ROOT = join(PACKAGE_ROOT, '../..');

/**
 * @type {import('vite').UserConfig}
 * @see https://vitejs.dev/config/
 */
const config = {
  mode: process.env.MODE,
  root: PACKAGE_ROOT,
  envDir: PROJECT_ROOT,
  resolve: {
    alias: {
      '/@/': join(PACKAGE_ROOT, 'src') + '/',
    },
  },
  build: {
    ssr: true,
    sourcemap: 'inline',
    target: `chrome${chrome}`,
    outDir: 'dist',
    assetsDir: '.',
    minify: process.env.MODE !== 'development',
    lib: {
      entry: 'src/index.ts',
      formats: ['cjs'],
    },
    rollupOptions: {
      output: {
        entryFileNames: '[name].cjs',
      },
    },
    emptyOutDir: true,
    reportCompressedSize: false,
  },
  plugins: [injectAppVersion()], // preload.vite() removed
  test: {
    coverage: {
      provider: 'istanbul',
    },
  },
};

export default config;


File: tests/site.test.ts
================================================
// packages/lib/tests/site.test.ts

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { TestSession } from '@peerbit/test-utils';
import type { ProgramClient } from '@peerbit/program';
import { Site, Release } from '../src/schema';
import type { ReleaseData } from '../src/types';
import {
  DEFAULT_SITE_ID,
  RELEASE_NAME_PROPERTY,
  RELEASE_CATEGORY_ID_PROPERTY,
  RELEASE_CONTENT_CID_PROPERTY,
  ID_PROPERTY,
  RELEASE_THUMBNAIL_CID_PROPERTY,
  RELEASE_METADATA_PROPERTY,
} from '../src/constants';
import { delay } from '@peerbit/time';

describe('Site Program', () => {
  let session: TestSession;
  let client: ProgramClient;
  let site: Site;

  beforeEach(async () => {
    session = await TestSession.connected(1);
    client = session.peers[0];
    site = new Site(DEFAULT_SITE_ID);
    await client.open(site);
  });

  afterEach(async () => {
    if (site && !site.closed) {
      await site.close();
    }
    if (session) {
      await session.stop();
    }
  });
  it('can create a site, add a release, and get the release', async () => {
    // 1. Prepare Release Data
    const releaseData: ReleaseData = {
      [RELEASE_NAME_PROPERTY]: 'RiP!: A Remix Manifesto',
      [RELEASE_CATEGORY_ID_PROPERTY]: 'movie',
      [RELEASE_CONTENT_CID_PROPERTY]: 'QmTWWUmvC9txvE7aHs9xHd541qLx3ax58urvx3Kb3SFK2Q',
      [RELEASE_THUMBNAIL_CID_PROPERTY]: 'Qmb3eeESRoX5L6NhTYLEtFFUS1FZgqe1e7hdBk2f57DUGh',
    };

    // 2. Create a Release instance (this will auto-generate an ID)
    const newReleaseInstance = new Release(releaseData);
    const expectedReleaseId = newReleaseInstance[ID_PROPERTY];


    // 3. Add the Release to the Site's releases store
    const entryHash = await site.addRelease(newReleaseInstance);
    expect(entryHash).toBeTypeOf('string');
    expect(entryHash.length).toBeGreaterThan(0);

    await delay(200);

    // 4. Get the Release using its ID
    const retrievedRelease = await site.getRelease(expectedReleaseId);
    // 5. Assertions
    expect(retrievedRelease).toBeDefined();
    expect(retrievedRelease).not.toBeNull();

    if (retrievedRelease) {
      expect(retrievedRelease[ID_PROPERTY]).toEqual(expectedReleaseId);
      expect(retrievedRelease[RELEASE_NAME_PROPERTY]).toEqual(releaseData[RELEASE_NAME_PROPERTY]);
      expect(retrievedRelease[RELEASE_CATEGORY_ID_PROPERTY]).toEqual(releaseData[RELEASE_CATEGORY_ID_PROPERTY]);
      expect(retrievedRelease[RELEASE_CONTENT_CID_PROPERTY]).toEqual(releaseData[RELEASE_CONTENT_CID_PROPERTY]);

      // Check optional properties if they were set
      if (releaseData[RELEASE_THUMBNAIL_CID_PROPERTY]) {
        expect(retrievedRelease[RELEASE_THUMBNAIL_CID_PROPERTY]).toEqual(releaseData[RELEASE_THUMBNAIL_CID_PROPERTY]);
      }
      if (releaseData[RELEASE_METADATA_PROPERTY]) {
        expect(retrievedRelease[RELEASE_METADATA_PROPERTY]).toEqual(releaseData[RELEASE_METADATA_PROPERTY]);
      }
    }

  });

  it('getRelease returns undefined for a non-existent ID', async () => {
    const nonExistentId = 'non-existent-id-12345';
    const retrievedRelease = await site.getRelease(nonExistentId);
    expect(retrievedRelease).toBeUndefined();
  });
});


File: src/schema.ts
================================================
import { Documents, SearchRequest, Sort, SortDirection } from '@peerbit/document';
import { deserialize, field, option, variant } from '@dao-xyz/borsh';
import { PublicSignKey } from '@peerbit/crypto';
import { sha256Sync } from '@peerbit/crypto';
import { Program } from '@peerbit/program';
import type { ReplicationOptions } from '@peerbit/shared-log';
import { v4 as uuid } from 'uuid';
import { concat } from 'uint8arrays';
import {
  ID_PROPERTY,
  RELEASE_NAME_PROPERTY,
  RELEASE_CATEGORY_ID_PROPERTY,
  RELEASE_CONTENT_CID_PROPERTY,
  RELEASE_THUMBNAIL_CID_PROPERTY,
  RELEASE_METADATA_PROPERTY,
  FEATURED_RELEASE_ID_PROPERTY,
  FEATURED_START_TIME_PROPERTY,
  FEATURED_END_TIME_PROPERTY,
  FEATURED_PROMOTED_PROPERTY,
  CONTENT_CATEGORY_DISPLAY_NAME_PROPERTY,
  CONTENT_CATEGORY_DESCRIPTION_PROPERTY,
  CONTENT_CATEGORY_FEATURED_PROPERTY,
  CONTENT_CATEGORY_METADATA_SCHEMA_PROPERTY,
  SUBSCRIPTION_SITE_ID_PROPERTY,
  SUBSCRIPTION_NAME_PROPERTY,
  BLOCKED_CONTENT_CID_PROPERTY,
} from './constants';

import type {
  IdData,
  ReleaseData,
  FeaturedReleaseData,
  ContentCategoryData,
  SubcriptionData,
  BlockedContentData,
} from './types';

@variant(0)
export class Release {
  @field({ type: 'string' })
  [ID_PROPERTY]: string;

  @field({ type: 'string' })
  [RELEASE_NAME_PROPERTY]: string;

  @field({ type: 'string' })
  [RELEASE_CATEGORY_ID_PROPERTY]: string;

  @field({ type: 'string' })
  [RELEASE_CONTENT_CID_PROPERTY]: string;

  @field({ type: option('string') })
  [RELEASE_THUMBNAIL_CID_PROPERTY]?: string;

  @field({ type: option('string') })
  [RELEASE_METADATA_PROPERTY]?: string;

  constructor(props: ReleaseData) {
    this[ID_PROPERTY] = uuid();
    this[RELEASE_NAME_PROPERTY] = props[RELEASE_NAME_PROPERTY];
    this[RELEASE_CATEGORY_ID_PROPERTY] = props[RELEASE_CATEGORY_ID_PROPERTY];
    this[RELEASE_CONTENT_CID_PROPERTY] = props[RELEASE_CONTENT_CID_PROPERTY];
    if (props[RELEASE_THUMBNAIL_CID_PROPERTY]) {
      this[RELEASE_THUMBNAIL_CID_PROPERTY] = props[RELEASE_THUMBNAIL_CID_PROPERTY];
    }
    if (props[RELEASE_METADATA_PROPERTY]) {
      this[RELEASE_METADATA_PROPERTY] = props[RELEASE_METADATA_PROPERTY];
    }
  }
}

export class IndexableRelease {
  @field({ type: 'string' })
  [ID_PROPERTY]: string;

  @field({ type: 'string' })
  [RELEASE_NAME_PROPERTY]: string;

  @field({ type: 'string' })
  [RELEASE_CATEGORY_ID_PROPERTY]: string;

  @field({ type: 'string' })
  [RELEASE_CONTENT_CID_PROPERTY]: string;

  @field({ type: option('string') })
  [RELEASE_THUMBNAIL_CID_PROPERTY]?: string;

  @field({ type: option('string') })
  [RELEASE_METADATA_PROPERTY]?: string;

  @field({ type: 'u64' })
  created: bigint;

  @field({ type: 'u64' })
  modified: bigint;

  @field({ type: Uint8Array })
  author: Uint8Array;

  constructor(
    release: IdData & ReleaseData,
    createdAt: bigint,
    modified: bigint,
    author: PublicSignKey,
  ) {
    this[ID_PROPERTY] = release[ID_PROPERTY];
    this[RELEASE_NAME_PROPERTY] = release[RELEASE_NAME_PROPERTY];
    this[RELEASE_CATEGORY_ID_PROPERTY] = release[RELEASE_CATEGORY_ID_PROPERTY];
    this[RELEASE_CONTENT_CID_PROPERTY] = release[RELEASE_CONTENT_CID_PROPERTY];
    if (release[RELEASE_THUMBNAIL_CID_PROPERTY]) {
      this[RELEASE_THUMBNAIL_CID_PROPERTY] = release[RELEASE_THUMBNAIL_CID_PROPERTY];
    }
    if (release[RELEASE_METADATA_PROPERTY]) {
      this[RELEASE_METADATA_PROPERTY] = release[RELEASE_METADATA_PROPERTY];
    }
    this.created = createdAt;
    this.modified = modified;
    this.author = author.bytes;
  }
}

@variant(0)
export class FeaturedRelease {
  @field({ type: 'string' })
  [ID_PROPERTY]: string;

  @field({ type: 'string' })
  [FEATURED_RELEASE_ID_PROPERTY]: string;

  @field({ type: 'string' })
  [FEATURED_START_TIME_PROPERTY]: string;

  @field({ type: 'string' })
  [FEATURED_END_TIME_PROPERTY]: string;

  @field({ type: 'bool' })
  [FEATURED_PROMOTED_PROPERTY]: boolean;

  constructor(props: FeaturedReleaseData) {
    this[ID_PROPERTY] = uuid();
    this[FEATURED_RELEASE_ID_PROPERTY] = props[FEATURED_RELEASE_ID_PROPERTY];
    this[FEATURED_START_TIME_PROPERTY] = props[FEATURED_START_TIME_PROPERTY];
    this[FEATURED_END_TIME_PROPERTY] = props[FEATURED_END_TIME_PROPERTY];
    this[FEATURED_PROMOTED_PROPERTY] = props[FEATURED_PROMOTED_PROPERTY];
  }
}

@variant(0)
export class ContentCategory {
  @field({ type: 'string' })
  [ID_PROPERTY]: string;

  @field({ type: 'string' })
  [CONTENT_CATEGORY_DISPLAY_NAME_PROPERTY]: string;

  @field({ type: 'bool' })
  [CONTENT_CATEGORY_FEATURED_PROPERTY]: boolean;

  @field({ type: option('string') })
  [CONTENT_CATEGORY_DESCRIPTION_PROPERTY]?: string;

  @field({ type: option('string') })
  [CONTENT_CATEGORY_METADATA_SCHEMA_PROPERTY]?: string;

  constructor(props: ContentCategoryData) {
    this[ID_PROPERTY] = props[ID_PROPERTY];
    this[CONTENT_CATEGORY_DISPLAY_NAME_PROPERTY] = props[CONTENT_CATEGORY_DISPLAY_NAME_PROPERTY];
    this[CONTENT_CATEGORY_FEATURED_PROPERTY] = props[CONTENT_CATEGORY_FEATURED_PROPERTY];
    if (props[CONTENT_CATEGORY_DESCRIPTION_PROPERTY]) {
      this[CONTENT_CATEGORY_DESCRIPTION_PROPERTY] = props[CONTENT_CATEGORY_DESCRIPTION_PROPERTY];
    }
    if (props[CONTENT_CATEGORY_METADATA_SCHEMA_PROPERTY]) {
      this[CONTENT_CATEGORY_METADATA_SCHEMA_PROPERTY] = props[CONTENT_CATEGORY_METADATA_SCHEMA_PROPERTY];
    }
  }
}

@variant(0)
export class Subscription {
  @field({ type: 'string' })
  [ID_PROPERTY]: string;

  @field({ type: 'string' })
  [SUBSCRIPTION_SITE_ID_PROPERTY]: string;

  @field({ type: option('string') })
  [SUBSCRIPTION_NAME_PROPERTY]?: string;

  constructor(props: SubcriptionData) {
    this[ID_PROPERTY] = uuid();
    this[SUBSCRIPTION_SITE_ID_PROPERTY] = props[SUBSCRIPTION_SITE_ID_PROPERTY];
    if (props[SUBSCRIPTION_NAME_PROPERTY]) {
      this[SUBSCRIPTION_NAME_PROPERTY] = props[SUBSCRIPTION_NAME_PROPERTY];
    }
  }
}

@variant(0)
export class BlockedContent {
  @field({ type: 'string' })
  [ID_PROPERTY]: string;

  @field({ type: 'string' })
  [BLOCKED_CONTENT_CID_PROPERTY]: string;

  constructor(props: BlockedContentData) {
    this[ID_PROPERTY] = uuid();
    this[BLOCKED_CONTENT_CID_PROPERTY] = props[BLOCKED_CONTENT_CID_PROPERTY];
  }
}


export enum AccountType {
  GUEST = 0,
  USER = 1,
  MODERATOR = 2,
  ADMIN = 3,
}

@variant(0)
export class Account {
  @field({ type: Uint8Array })
  id: Uint8Array;

  @field({ type: 'string' })
  name: string;

  @field({ type: 'u8' })
  type: AccountType;


  constructor(publicKey: PublicSignKey, name: string, type: AccountType) {
    this.id = publicKey.bytes;
    this.name = name;
    this.type = type;
  }

  get publicKey() {
    return deserialize(this.id, PublicSignKey);
  }
}

type Args = {
  replicate?: ReplicationOptions
};

@variant('site')
export class Site extends Program<Args> {

  @field({ type: Documents })
  releases: Documents<Release, IndexableRelease>;

  @field({ type: Documents })
  featuredReleases: Documents<FeaturedRelease>;

  @field({ type: Documents })
  contentCategories: Documents<ContentCategory>;

  @field({ type: Documents })
  users: Documents<Account>;

  @field({ type: Documents })
  subscriptions: Documents<Subscription>;

  @field({ type: Documents })
  blockedContent: Documents<BlockedContent>;

  constructor(siteIdString: string) {
    super();
    const textEncoder = new TextEncoder();
    const siteIdBytes = textEncoder.encode(siteIdString);

    const releasesSuffix = textEncoder.encode('releases');
    const featuredReleasesSuffix = textEncoder.encode('featuredReleases');
    const contentCategoriesSuffix = textEncoder.encode('contentCategories');
    const usersSuffix = textEncoder.encode('users');
    const subscriptionsSuffix = textEncoder.encode('subscriptions');
    const blockedContentSuffix = textEncoder.encode('blockedContent');

    this.releases = new Documents({
      id: sha256Sync(concat([siteIdBytes, releasesSuffix])),
    });

    this.featuredReleases = new Documents({
      id: sha256Sync(concat([siteIdBytes, featuredReleasesSuffix])),
    });

    this.contentCategories = new Documents({
      id: sha256Sync(concat([siteIdBytes, contentCategoriesSuffix])),
    });

    this.users = new Documents({
      id: sha256Sync(concat([siteIdBytes, usersSuffix])),
    });

    this.subscriptions = new Documents({
      id: sha256Sync(concat([siteIdBytes, subscriptionsSuffix])),
    });

    this.blockedContent = new Documents({
      id: sha256Sync(concat([siteIdBytes, blockedContentSuffix])),
    });
  }

  async open(args: Args): Promise<void> {
    await this.releases.open({
      type: Release,
      replicate: args?.replicate || {
        factor: 1,
      },
      canPerform: async () => {
        //TODO: implement access control
        return true;
      },
      index: {
        canRead: async () => {
          return true;
        },
        type: IndexableRelease,
        transform: async (release, ctx) => {
          return new IndexableRelease(
            release,
            ctx.created,
            ctx.modified,
            (await this.releases.log.log.get(
              ctx.head,
            ))!.signatures[0].publicKey,
          );
        },
      },
      replicas: {
        min: 2,
        max: undefined,
      },
    });
    await this.featuredReleases.open({
      type: FeaturedRelease,
      replicate: args?.replicate || {
        factor: 1,
      },
      canPerform: async () => {
        //TODO: implement access control
        return true;
      },
      replicas: {
        min: 2,
        max: undefined,
      },
    });
    await this.contentCategories.open({
      type: ContentCategory,
      replicate: args?.replicate || {
        factor: 1,
      },
      canPerform: async () => {
        //TODO: implement access control
        return true;
      },
      replicas: {
        min: 2,
        max: undefined,
      },
    });
    await this.users.open({
      type: Account,
      replicate: args?.replicate || {
        factor: 1,
      },
      canPerform: async () => {
        //TODO: implement access control
        return true;
      },
      replicas: {
        min: 2,
        max: undefined,
      },
    });
    await this.subscriptions.open({
      type: Subscription,
      replicate: args?.replicate || {
        factor: 1,
      },
      canPerform: async () => {
        //TODO: implement access control
        return true;
      },
      replicas: {
        min: 2,
        max: undefined,
      },
    });
    await this.blockedContent.open({
      type: BlockedContent,
      replicate: args?.replicate || {
        factor: 1,
      },
      canPerform: async () => {
        //TODO: implement access control
        return true;
      },
      replicas: {
        min: 2,
        max: undefined,
      },
    });
  }

  async addRelease(release: Release): Promise<string> {
    const result = await this.releases.put(release);
    return result.entry.hash;
  }

  async getRelease(id: string): Promise<Release | undefined> {
    return this.releases.index.get(id);
  }

  async getLatestReleases(size = 30): Promise<Release[]> {
    return this.releases.index.search(
      new SearchRequest({
        sort: [
          new Sort({ key: 'created', direction: SortDirection.DESC }),
        ],
        fetch: size,
      }),
    );
  }
}


File: src/constants.ts
================================================
export const DEFAULT_SITE_ID = 'default-site';

export const ID_PROPERTY = 'id';

export const RELEASE_NAME_PROPERTY = 'name';
export const RELEASE_CATEGORY_ID_PROPERTY = 'categoryId';
export const RELEASE_CONTENT_CID_PROPERTY = 'contentCID';
export const RELEASE_THUMBNAIL_CID_PROPERTY = 'thumbnailCID';
export const RELEASE_METADATA_PROPERTY = 'metadata';

export const FEATURED_RELEASE_ID_PROPERTY = 'releaseId';
export const FEATURED_START_TIME_PROPERTY = 'startTime';
export const FEATURED_END_TIME_PROPERTY = 'endTime';
export const FEATURED_PROMOTED_PROPERTY = 'promoted';

export const CONTENT_CATEGORY_DISPLAY_NAME_PROPERTY = 'displayName';
export const CONTENT_CATEGORY_DESCRIPTION_PROPERTY = 'description';
export const CONTENT_CATEGORY_FEATURED_PROPERTY = 'featured';
export const CONTENT_CATEGORY_METADATA_SCHEMA_PROPERTY = 'metadataSchema';

export const SUBSCRIPTION_SITE_ID_PROPERTY = 'siteId';
export const SUBSCRIPTION_NAME_PROPERTY = 'name';

export const BLOCKED_CONTENT_CID_PROPERTY = 'cid';


File: src/types.ts
================================================
import type { Release } from './schema';
import type {
  ID_PROPERTY,
  RELEASE_NAME_PROPERTY,
  RELEASE_CATEGORY_ID_PROPERTY,
  RELEASE_CONTENT_CID_PROPERTY,
  RELEASE_THUMBNAIL_CID_PROPERTY,
  RELEASE_METADATA_PROPERTY,
  FEATURED_RELEASE_ID_PROPERTY,
  FEATURED_START_TIME_PROPERTY,
  FEATURED_END_TIME_PROPERTY,
  FEATURED_PROMOTED_PROPERTY,
  CONTENT_CATEGORY_DISPLAY_NAME_PROPERTY,
  CONTENT_CATEGORY_DESCRIPTION_PROPERTY,
  CONTENT_CATEGORY_FEATURED_PROPERTY,
  CONTENT_CATEGORY_METADATA_SCHEMA_PROPERTY,
  SUBSCRIPTION_SITE_ID_PROPERTY,
  SUBSCRIPTION_NAME_PROPERTY,
  BLOCKED_CONTENT_CID_PROPERTY,
} from './constants';

export type AnyObject = Record<string, unknown>;

export type IdData = {
  [ID_PROPERTY]: string
};

export type ReleaseData<T = string> = {
  [RELEASE_NAME_PROPERTY]: string;
  [RELEASE_CATEGORY_ID_PROPERTY]: string;
  [RELEASE_CONTENT_CID_PROPERTY]: string;
  [RELEASE_THUMBNAIL_CID_PROPERTY]?: string;
  [RELEASE_METADATA_PROPERTY]?: T;
}

export type FeaturedReleaseData = {
  [FEATURED_RELEASE_ID_PROPERTY]: string;
  [FEATURED_START_TIME_PROPERTY]: string;
  [FEATURED_END_TIME_PROPERTY]: string;
  [FEATURED_PROMOTED_PROPERTY]: boolean;
}

export type ContentCategoryData<T = string> = IdData & {
  [CONTENT_CATEGORY_DISPLAY_NAME_PROPERTY]: string;
  [CONTENT_CATEGORY_FEATURED_PROPERTY]: boolean;
  [CONTENT_CATEGORY_DESCRIPTION_PROPERTY]?: string;
  [CONTENT_CATEGORY_METADATA_SCHEMA_PROPERTY]?: T;
}

export type ContentCategoryMetadata = Record<string, {
  type: 'string' | 'number' | 'array';
  description: string;
  options?: string[];
}>;

export type SubcriptionData = {
  [SUBSCRIPTION_SITE_ID_PROPERTY]: string;
  [SUBSCRIPTION_NAME_PROPERTY]?: string;
}

export type BlockedContentData = {
  [BLOCKED_CONTENT_CID_PROPERTY]: string;
}

export interface AddReleaseResponse {
  success: boolean;
  id: string;
  hash: string;
  message?: string;
  error?: string;
}

export interface IPeerbitService {
  getPublicKey: () => Promise<string>;
  getPeerId: () => Promise<string>;
  dial: (address: string) => Promise<boolean>;
  addRelease: (releaseData: ReleaseData) => Promise<AddReleaseResponse>;
  getRelease: (id: string) => Promise<Release | undefined>;
  getLatestReleases: (size?: number) => Promise<Release[]>;
  // updateRelease will also need to be defined here eventually
  // updateRelease?: (id: string, releaseData: any) => Promise<any>;
}


Summary:
Total files: 8
Total size: 24957 bytes
